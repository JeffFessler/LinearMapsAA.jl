var documenterSearchIndex = {"docs":
[{"location":"generated/examples/02-trace/#02-trace","page":"Operator example: trace","title":"Operator example: trace","text":"","category":"section"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"This page illustrates the \"linear operator\" feature of the Julia package LinearMapsAA.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"This page comes from a single Julia file: 02-trace.jl.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 02-trace.ipynb, or open it in binder here: 02-trace.ipynb.","category":"page"},{"location":"generated/examples/02-trace/#Setup","page":"Operator example: trace","title":"Setup","text":"","category":"section"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"Packages needed here.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"using LinearMapsAA\nusing LinearAlgebra: tr, I\nusing InteractiveUtils: versioninfo","category":"page"},{"location":"generated/examples/02-trace/#Overview","page":"Operator example: trace","title":"Overview","text":"","category":"section"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"The \"operator\" aspect of this package may seem unfamiliar to some readers who are used to thinking in terms of matrices and vectors, so this page describes a simple example: the matrix trace operation. The trace of a N  N matrix is the sum of its N diagonal elements. We tend to think of this a function, and indeed it is the tr function in the LinearAlgebra package. But it is a linear function so we can represent it as a linear operator 𝒜 that maps a N  N matrix into its trace. In other words, 𝒜  mathbbC^N  N mapsto mathbbC is defined by 𝒜 X = mathrmtr(X). Note that the product 𝒜 X is not a \"matrix vector\" product; it is a linear operator acting on the matrix X.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"(Note that we use a fancy unicode character 𝒜 here just as a reminder that it is an operator; in practical code we usually just use A.)","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"The LinearMapsAA package can represent such an operator easily. Here is the definition for N = 5:","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"N = 5\nforw(X) = [tr(X)] # forward mapping function\n𝒜 = LinearMapAA(forw, (1, N*N); idim = (N,N), odim = (1,))","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"The idim argument specifies that the input is a matrix of size N × N and the odim argument specifies that the output is vector of size (1,).","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"One subtlety with this particular didactic example is that the ordinary trace yields a scalar, but LinearMaps.jl is (understandably) designed exclusively for mapping vectors to vectors, so we use [tr(X)] above so that the output is a 1-element Vector. This behavior is consistent with what happens when one multiplies a 1 × N matrix with a vector in mathbbC^N.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"Here is a verification that applying this operator to a matrix produces the correct result:","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"X = ones(5)*(1:5)'\n𝒜 * X, tr(X), (N*(N+1))÷2","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"Although 𝒜 here is not a matrix, we can convert it to a matrix (at least when N is sufficiently small) to perhaps understand it better:","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"A = Matrix(𝒜)\nA = Int8.(A) # just for nicer display","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"The pattern of 0 and 1 elements is more obvious when reshaped:","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"reshape(A, N, N)","category":"page"},{"location":"generated/examples/02-trace/#Adjoint","page":"Operator example: trace","title":"Adjoint","text":"","category":"section"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"Although this is largely a didactic example, there are optimization problems with trace constraints of the form 𝒜 X = b. To solve such problems, often one would also need the adjoint of the operator 𝒜.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"Mathematically, and adjoint is a generalization of the (Hermitian) transpose of a matrix. For a (bounded) linear mapping 𝒜 between inner product space 𝒳 with inner product  cdot cdot rangle_𝒳 and inner product space 𝒴 with inner product  cdot cdot rangle_𝒴 the adjoint of 𝒜, denoted 𝒜, is the unique bound linear mapping that satisfies  𝒜 x y rangle_𝒴 =  x 𝒜 y rangle_𝒳 for all x  𝒳 and y  𝒴.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"Here, let 𝒳 denote the vector space of N  N matrices with the Frobenius inner product for matrices:  A B rangle_𝒳 = mathrmtr(AB). Let 𝒴 simply be mathbbC^1 with the usual inner product  x y rangle_𝒴 = x_1^* y_1.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"With those definitions, one can verify that the adjoint of 𝒜 is the mapping 𝒜 c = c_1 mathbfI_N, for c  mathbbC^1, where mathbfI_N denotes the N  N identity matrix.","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"Here is the LinearMapAO that includes the adjoint:","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"back(y) = y[1] * I(N) # remember `y` is a 1-vector\n𝒜 = LinearMapAA(forw, back, (1, N*N); idim = (N,N), odim = (1,))","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"Here is a verification that the adjoint is correct (very important!):","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"@assert Matrix(𝒜)' == Matrix(𝒜')\nInt8.(Matrix(𝒜'))","category":"page"},{"location":"generated/examples/02-trace/#Reproducibility","page":"Operator example: trace","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"using InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"And with the following package versions","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"","category":"page"},{"location":"generated/examples/02-trace/","page":"Operator example: trace","title":"Operator example: trace","text":"This page was generated using Literate.jl.","category":"page"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/#LinearMapsAA.LinearMapsAA","page":"Methods","title":"LinearMapsAA.LinearMapsAA","text":"module LinearMapsAA\n\nProvides AbstractArray (actually AbstractMatrix) or \"Ann Arbor\" version of LinearMap objects\n\n\n\n\n\n","category":"module"},{"location":"methods/#LinearMapsAA.LinearMapAX","page":"Methods","title":"LinearMapsAA.LinearMapAX","text":"struct LinearMapAX{T,Do,Di,LM,P}\n\nUnion of LinearMapAM and LinearMapAO because most operations apply to both AM and AO types.\n\nT : eltype\nDo : output dimensionality\nDi : input dimensionality\nLM : LinearMap type\nP : NamedTuple type\n\n\n\n\n\n","category":"type"},{"location":"methods/#LinearMapsAA.LinearMapAM","page":"Methods","title":"LinearMapsAA.LinearMapAM","text":"struct LinearMapAM{T,Do,Di,LM,P} <: AbstractMatrix{T}\n\n\"matrix\" version that is quite akin to a matrix in its behavior\n\n\n\n\n\n","category":"type"},{"location":"methods/#LinearMapsAA.LinearMapAO","page":"Methods","title":"LinearMapsAA.LinearMapAO","text":"struct LinearMapAO{T,Do,Di,LM,P}\n\n\"Tensor\" version that can map from arrays to arrays. (It is not a subtype of AbstractArray.)\n\n\n\n\n\n","category":"type"},{"location":"methods/#LinearMapsAA.LinearMapAO-Union{Tuple{LinearMapAX{T, Do, Di, LM, P}}, Tuple{P}, Tuple{LM}, Tuple{Di}, Tuple{Do}, Tuple{T}} where {T, Do, Di, LM, P}","page":"Methods","title":"LinearMapsAA.LinearMapAO","text":"B = LinearMapAO(A::LinearMapAX)\n\nMake an AO from an AM, despite idim and odim being 1D, for expert users who want B*X to be an Array. Somewhat an opposite of undim.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.:*-Tuple{LinearAlgebra.UniformScaling, AbstractArray}","page":"Methods","title":"Base.:*","text":"*(I, X) = X\n*(J, X) = J.λ * X\n\nExtends the effect of I::UniformScaling and scaled versions thereof to also apply to X::AbstractArray instead of just to Vector and Matrix types.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.:*-Tuple{LinearMapAO, AbstractVector{<:AbstractArray}}","page":"Methods","title":"Base.:*","text":"*(A::LinearMapAO, xv::AbstractVector{<:AbstractArray}) = [A * x for x in xv]\n\nFancy multiply when xv is a Vector of AbstractArrays of appropriate size.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.hcat-Tuple{LinearMapAO, Vararg{LinearMapAO}}","page":"Methods","title":"Base.hcat","text":"hcat(As::LinearMapAO... ; tryop::Bool=true)\n\nhcat with (by default) attempt to append nblock to idim if consistent blocks.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.hvcat-Tuple{NTuple{nr, Int64} where nr, LinearMapAO, Vararg{LinearMapAO}}","page":"Methods","title":"Base.hvcat","text":"hvcat(rows, As::LinearMapAO...)\n\nhvcat that discards special idim and odim information (too hard!) # todo?\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.kron-Tuple{LinearMapAM, AbstractMatrix}","page":"Methods","title":"Base.kron","text":"kron(A::LinearMapAX, M::AbstractMatrix)\nkron(M::AbstractMatrix, A::LinearMapAX)\nkron(A::LinearMapAX, B::LinearMapAX)\n\nKronecker products\n\nReturns a LinearMapAO with appropriate idim and odim if either argument is a LinearMapAO else returns a LinearMapAM\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Tuple{IO, LinearMapAX}","page":"Methods","title":"Base.show","text":"show(io::IO, A::LinearMapAX)\nshow(io::IO, ::MIME\"text/plain\", A::LinearMapAX)\n\nPretty printing for display\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.vcat-Tuple{LinearMapAO, Vararg{LinearMapAO}}","page":"Methods","title":"Base.vcat","text":"vcat(As::LinearMapAO... ; tryop::Bool=true)\n\nvcat with (by default) attempt to append nblock to odim if consistent blocks.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearAlgebra.mul!-Tuple{AbstractVector{<:AbstractArray}, LinearMapAO, AbstractVector{<:AbstractArray}, Number, Number}","page":"Methods","title":"LinearAlgebra.mul!","text":" mul!(yv, AO::LinearMapAO, xv, α, β)\n\nFancy 5-arg multiply when yv and xv are each a Vector of AbstractArrays. Basically does mul!(yv[i], A, xv[i], α, β) for i in 1:length(xv).\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.LinearMapAA-Tuple{AbstractMatrix}","page":"Methods","title":"LinearMapsAA.LinearMapAA","text":"A = LinearMapAA(L::AbstractMatrix ; ...)\n\nConstructor given an AbstractMatrix.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.LinearMapAA-Tuple{Function, Function, Tuple{Int64, Int64}}","page":"Methods","title":"LinearMapsAA.LinearMapAA","text":"A = LinearMapAA(f::Function, fc::Function, D::Dims{2} [, prop::NamedTuple)]\n; T::Type = Float32, idim::Dims, odim::Dims)\n\nConstructor given forward f and adjoint function fc.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.LinearMapAA-Tuple{Function, Tuple{Int64, Int64}}","page":"Methods","title":"LinearMapsAA.LinearMapAA","text":"A = LinearMapAA(f::Function, D::Dims{2} [, prop::NamedTuple]; kwargs...)\n\nConstructor given just forward function f.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.LinearMapAA-Union{Tuple{P}, Tuple{LM}, Tuple{Do}, Tuple{Di}} where {Di, Do, LM<:LinearMaps.LinearMap, P<:NamedTuple}","page":"Methods","title":"LinearMapsAA.LinearMapAA","text":"A = LinearMapAA(L::LinearMap ; ...)\n\nConstructor for LinearMapAM  or LinearMapAO given a LinearMap.\n\nOptions\n\nprop::NamedTuple = NamedTuple(); cannot include the fields _lmap, _prop, _idim, _odim\nT::Type = eltype(L)\nidim::Dims = (size(L,2),)\nodim::Dims = (size(L,1),)\noperator::Bool by default: false if both idim & odim are 1D.\n\nOutput A is LinearMapAO if operator is true, else LinearMapAM.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.block_diag-Tuple{Vararg{LinearMapAO}}","page":"Methods","title":"LinearMapsAA.block_diag","text":"B = block_diag(As::LinearMapAX... ; tryop::Bool)\n\nMake block diagonal LinearMapAX object from blocks.\n\nReturn a LinearMapAM unless tryop and all blocks have same idim and odim.\n\nDefault for tryop is true if all blocks are type LinearMapAO.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.lmaa_hcat-Tuple{Vararg{Union{LinearAlgebra.UniformScaling{T}, LinearMaps.LinearMap{T}, LinearMapAM{T}, LinearMapAO{T}} where T}}","page":"Methods","title":"LinearMapsAA.lmaa_hcat","text":"B = lmaa_hcat(A1, A2, ...) hcat of multiple objects\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.lmaa_hvcat-Tuple{NTuple{nr, Int64} where nr, Vararg{Union{LinearAlgebra.UniformScaling{T}, LinearMaps.LinearMap{T}, LinearMapAM{T}, LinearMapAO{T}} where T}}","page":"Methods","title":"LinearMapsAA.lmaa_hvcat","text":"B = lmaa_hvcat(rows, A1, A2, ...) hvcat of multiple objects\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.lmaa_vcat-Tuple{Vararg{Union{LinearAlgebra.UniformScaling{T}, LinearMaps.LinearMap{T}, LinearMapAM{T}, LinearMapAO{T}} where T}}","page":"Methods","title":"LinearMapsAA.lmaa_vcat","text":"B = lmaa_vcat(A1, A2, ...) vcat of multiple objects\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.lmao_mul!-Tuple{AbstractArray, LinearMaps.LinearMap, AbstractArray, Number, Number}","page":"Methods","title":"LinearMapsAA.lmao_mul!","text":" lmao_mul!(Y, A, X, α, β ; idim, odim)\n\nCore routine for 5-arg multiply. If A._idim = (2,3,4) and A._odim = (5,6) and if input X has size (2,3,4, 7,8) then output Y will have size (5,6, 7,8)\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.redim-Union{Tuple{LinearMapAX{T}}, Tuple{T}} where T","page":"Methods","title":"LinearMapsAA.redim","text":"redim(A::LinearMapAX ; idim::Dims=A._idim, odim::Dims=A._odim)\n\n\"Reinterpret\" the idim and odim of A\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.undim-Union{Tuple{LinearMapAX{T}}, Tuple{T}} where T","page":"Methods","title":"LinearMapsAA.undim","text":"undim(A::LinearMapAX)\n\n\"Reinterpret\" the idim and odim of A to be of AM type\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/01-overview/#01-overview","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"This page illustrates the Julia package LinearMapsAA.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"This page comes from a single Julia file: 01-overview.jl.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 01-overview.ipynb, or open it in binder here: 01-overview.ipynb.","category":"page"},{"location":"generated/examples/01-overview/#Setup","page":"LinearMapsAA overview","title":"Setup","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Packages needed here.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"using LinearMapsAA\nusing ImagePhantoms: shepp_logan, SheppLoganToft\nusing MIRTjim: jim, prompt\nusing InteractiveUtils: versioninfo","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/#Overview","page":"LinearMapsAA overview","title":"Overview","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Many computational imaging methods use system models that are too large to store explicitly as dense matrices, but nevertheless are represented mathematically by a linear mapping A.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Often that linear map is thought of as a matrix, but in imaging problems it often is more convenient to think of it as a more general linear operator.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"The LinearMapsAA package can represent both \"matrix\" versions and \"operator\" versions of linear mappings. This page illustrates both versions in the context of single-image super-resolution imaging, where the operator A maps a M × N image into a coarser sampled image of size M÷2 × N÷2.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Here the operator A is akin to down-sampling, except, rather than simple decimation, each coarse-resolution pixel is the average of a 2 × 2 block of pixels in the fine-resolution image.","category":"page"},{"location":"generated/examples/01-overview/#System-operator-(linear-mapping)-for-down-sampling","page":"LinearMapsAA overview","title":"System operator (linear mapping) for down-sampling","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Here is the \"forward\" function needed to model 2× down-sampling:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"down1 = (x) -> (x[1:2:end,:] + x[2:2:end,:])/2 # 1D down-sampling by 2×\ndown2 = (x) -> down1(down1(x)')'; # 2D down-sampling by factor of 2×\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"The down2 function is a (bounded) linear operator and here is its adjoint:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"down2_adj(y::AbstractMatrix{<:Number}) = kron(y, fill(0.25, (2,2)));\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Mathematically, and adjoint is a generalization of the (Hermitian) transpose of a matrix. For a (bounded) linear mapping A between inner product space X with inner product <.,.>X and inner product space Y with inner product <.,.>Y, the adjoint of A, denoted A', is the unique bound linear mapping that satisfies <A x, y>Y = <x, A' y>X for all x ∈ X and y ∈ Y. One can verify that the down2_adj function satisfies that equality for the usual inner product on the space of M × N images.","category":"page"},{"location":"generated/examples/01-overview/#LinearMap-as-an-operator-for-super-resolution","page":"LinearMapsAA overview","title":"LinearMap as an operator for super-resolution","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"We now pick a specific image size and define the linear mapping using the two functions above:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"nx, ny = 200, 256\nA = LinearMapAA(down2, down2_adj, ((nx÷2)*(ny÷2), nx*ny);\n    idim = (nx,ny), odim = (nx,ny) .÷ 2)","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"The idim argument specifies that the input image is of size nx × ny and the odim argument specifies that the output image is of size nx÷2 × ny÷2. This means that when we invoke y = A * x the input x must be a 2D array of size nx × ny (not a 1D vector!) and the output y will have size nx÷2 × ny÷2. This behavior is a generalization of what one might expect from a conventional matrix-vector expression, but is quite appropriate and convenient for imaging problems.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Here is an illustration. We start with a 2D test image.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"image = shepp_logan(ny, SheppLoganToft())[(ny-nx)÷2 .+ (1:nx),:]\njim(image, \"SheppLogan\")","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Apply the operator A to this image to down-sample it:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"down = A * image\njim(down, title=\"Down-sampled image\")","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Apply the adjoint of A to that result to \"up-sample\" it:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"up = A' * down\njim(up, title=\"Adjoint: A' * y\")","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"That up-sampled image does not have the same range of values as the original image because A' is an adjoint, not an inverse!","category":"page"},{"location":"generated/examples/01-overview/#AbstractMatrix-version","page":"LinearMapsAA overview","title":"AbstractMatrix version","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Some users may prefer that the operator A behave more like a matrix. We can implement approach from the same ingredients by using vec and reshape judiciously. The code is less elegant, but similarly efficient because vec and reshape are non-allocating operations.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"B = LinearMapAA(\n        x -> vec(down2(reshape(x,nx,ny))),\n        y -> vec(down2_adj(reshape(y,Int(nx/2),Int(ny/2)))),\n        ((nx÷2)*(ny÷2), nx*ny),\n    )","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"To apply this version to our image we must first vectorize it because the expected input is a vector in this case. And then we have to reshape the vector output as a 2D array to look at it. (This is why the operator version with idim and odim is preferable.)","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"y = B * vec(image) # This would fail here without the `vec`!\njim(reshape(y, nx÷2, ny÷2)) # Annoying reshape needed here!","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Even though we write y = A * x above, one must remember that internally A is not stored as a dense matrix. It is simply a special variable type that stores the forward function down2 and the adjoint function down2_adj, along with a few other values like nx,ny, and applies those functions when needed. Nevertheless, we can examine elements of A and B just like one would with any matrix, at least for small enough examples to fit in memory.","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Examine A and A'","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"nx, ny = 8,6\nidim = (nx,ny)\nodim = (nx,ny) .÷ 2\nA = LinearMapAA(down2, down2_adj, ((nx÷2)*(ny÷2), nx*ny); idim, odim)","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Here is A shown as a Matrix:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"jim(Matrix(A)', \"A\")","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Here is A' shown as a Matrix:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"jim(Matrix(A')', \"A'\")","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"When defining the adjoint function of a linear mapping, it is very important to verify that it is correct (truly the adjoint).","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"For a small problem we simply use the following test:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"@assert Matrix(A)' == Matrix(A')","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"For some applications we must check approximate equality like this:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"@assert Matrix(A)' ≈ Matrix(A')","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"Here is a statistical test that is suitable for large operators. Often one would repeat this test several times:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"T = eltype(A)\nx = randn(T, idim)\ny = randn(T, odim)\n\n@assert sum((A*x) .* y) ≈ sum(x .* (A'*y)) # <Ax,y> = <x,A'y>","category":"page"},{"location":"generated/examples/01-overview/#Reproducibility","page":"LinearMapsAA overview","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"using InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"And with the following package versions","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"","category":"page"},{"location":"generated/examples/01-overview/","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/03-fft/#03-fft","page":"Operator example: FFT","title":"Operator example: FFT","text":"","category":"section"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"This page illustrates the \"linear operator\" feature of the Julia package LinearMapsAA for the case of a multi-dimensional FFT operation.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"This page comes from a single Julia file: 03-fft.jl.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 03-fft.ipynb, or open it in binder here: 03-fft.ipynb.","category":"page"},{"location":"generated/examples/03-fft/#Setup","page":"Operator example: FFT","title":"Setup","text":"","category":"section"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Packages needed here.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"using LinearMapsAA\nusing FFTW: fft, bfft, fft!, bfft!\nusing MIRTjim: jim, prompt\nusing LazyGrids: btime\nusing BenchmarkTools: @benchmark\nusing InteractiveUtils: versioninfo","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/03-fft/#Overview","page":"Operator example: FFT","title":"Overview","text":"","category":"section"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"A 1D N-point discrete Fourier transform (DFT) is a linear operation that is naturally represented as a N × N matrix.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"The multi-dimensional DFT is a linear mapping that could be represented as a matrix, using the vec(⋅) of its arguments, but it is more naturally represented as a linear operator A. For 2D images of size M  N, we can think the DFT as an operator A that maps a M  N matrix into a M  N matrix of DFT coefficients. In other words, A  mathbbC^M  N mapsto mathbbC^M  N.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"The LinearMapsAA package can represent such an operator easily.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"We first define appropriate forward and adjoint functions. We use fft! and bfft! to avoid unnecessary memory allocations.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"forw!(y, x) =  fft!(copyto!(y, x)) # forward mapping function\nback!(x, y) = bfft!(copyto!(x, y)) # adjoint mapping function","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Below is the operator definition for (MN) = (816).","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Because FFT returns complex numbers, we must use T=ComplexF32 here for LinearMaps to work properly.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"M,N = 16,8\nT = ComplexF32\nA = LinearMapAA(forw!, back!, (M*N, M*N); idim = (M,N), odim = (M,N), T)","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"The idim argument specifies that the input is a matrix of size M × N and the odim argument specifies that the output is a matrix of size (M,N).","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Here is some verification that applying this operator to a matrix produces a correct result:","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"X = ones(M,N)\n@assert A * X ≈ M*N * ((1:M) .== 1)*((1:N) .== 1)' # Kronecker impulse\nX = rand(T, M, N)\n@assert A * X ≈ fft(X)","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Although A here is not a matrix, we can convert it to a matrix (at least when M N is sufficiently small) to perhaps understand it better:","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Amat = Matrix(A)\nusing MIRTjim: jim\njim(\n jim(real(Amat)', \"Real(A)\"; prompt=false),\n jim(imag(Amat)', \"Imag(A)\"; prompt=false),\n)","category":"page"},{"location":"generated/examples/03-fft/#Adjoint","page":"Operator example: FFT","title":"Adjoint","text":"","category":"section"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Here is a verification that the adjoint of the operator A is working correctly.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"@assert Matrix(A)' ≈ Matrix(A')","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Some users might wonder if there is \"overhead\" in using the overloaded linear mapping A * x or mul!(y, A, x) compared to directly calling fft!(copyto!(y), x).","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"Here are some timing tests that confirm that LinearMapsAA does not incur overhead.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"We deliberately choose very small M,N, because any overhead will be most apparent when the fft computation itself is fast.","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"x = rand(ComplexF32, M, N)\ny1 = similar(x)\ny2 = similar(x)\n\nmul!(y1, A, x)\nforw!(y2, x)\n@assert y1 == y2\nmul!(y1, A', x)\nback!(y2, x)\n@assert y1 == y2","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"time forward fft:","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"timer(t) = btime(t; unit=:μs)\nt = @benchmark forw!($y2, $x)       # 19.1 us (31 alloc, 2K)\ntimer(t)","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"compare to LinearMapsAA version:","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"t = @benchmark mul!($y1, $A, $x)    # 18.1 us (44 alloc, 4K)\ntimer(t)","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"time backward fft:","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"t = @benchmark back!($y2, $x)       # 19.443 μs (31 allocations: 2.12 KiB)\ntimer(t)","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"compare to LinearMapsAA version:","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"t = @benchmark mul!($y1, $(A'), $x) # 17.855 μs (44 allocations: 4.00 KiB)\ntimer(t)","category":"page"},{"location":"generated/examples/03-fft/#Reproducibility","page":"Operator example: FFT","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"using InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"And with the following package versions","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"","category":"page"},{"location":"generated/examples/03-fft/","page":"Operator example: FFT","title":"Operator example: FFT","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#LinearMapsAA.jl-Documentation","page":"Home","title":"LinearMapsAA.jl Documentation","text":"","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently the main documentation for (LinearMapsAA) is in the README file therein.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the documentation for the underlying (LinearMaps) package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Example(s) tab for one non-trivial example.","category":"page"}]
}
