var documenterSearchIndex = {"docs":
[{"location":"generated/examples/02-trace/#02-trace","page":"Operator example: trace","title":"Operator example: trace","text":"This page illustrates the \"linear operator\" feature of the Julia package LinearMapsAA.\n\nThis page comes from a single Julia file: 02-trace.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 02-trace.ipynb, or open it in binder here: 02-trace.ipynb.","category":"section"},{"location":"generated/examples/02-trace/#Setup","page":"Operator example: trace","title":"Setup","text":"Packages needed here.\n\nusing LinearMapsAA\nusing LinearAlgebra: tr, I\nusing InteractiveUtils: versioninfo","category":"section"},{"location":"generated/examples/02-trace/#Overview","page":"Operator example: trace","title":"Overview","text":"The \"operator\" aspect of this package may seem unfamiliar to some readers who are used to thinking in terms of matrices and vectors, so this page describes a simple example: the matrix trace operation. The trace of a N  N matrix is the sum of its N diagonal elements. We tend to think of this a function, and indeed it is the tr function in the LinearAlgebra package. But it is a linear function so we can represent it as a linear operator ğ’œ that maps a N  N matrix into its trace. In other words, ğ’œ  mathbbC^N  N mapsto mathbbC is defined by ğ’œ X = mathrmtr(X). Note that the product ğ’œ X is not a \"matrix vector\" product; it is a linear operator acting on the matrix X.\n\n(Note that we use a fancy unicode character ğ’œ here just as a reminder that it is an operator; in practical code we usually just use A.)\n\nThe LinearMapsAA package can represent such an operator easily. Here is the definition for N = 5:\n\nN = 5\nforw(X) = [tr(X)] # forward mapping function\nğ’œ = LinearMapAA(forw, (1, N*N); idim = (N,N), odim = (1,))\n\nThe idim argument specifies that the input is a matrix of size N Ã— N and the odim argument specifies that the output is vector of size (1,).\n\nOne subtlety with this particular didactic example is that the ordinary trace yields a scalar, but LinearMaps.jl is (understandably) designed exclusively for mapping vectors to vectors, so we use [tr(X)] above so that the output is a 1-element Vector. This behavior is consistent with what happens when one multiplies a 1 Ã— N matrix with a vector in mathbbC^N.\n\nHere is a verification that applying this operator to a matrix produces the correct result:\n\nX = ones(5)*(1:5)'\nğ’œ * X, tr(X), (N*(N+1))Ã·2\n\nAlthough ğ’œ here is not a matrix, we can convert it to a matrix (at least when N is sufficiently small) to perhaps understand it better:\n\nA = Matrix(ğ’œ)\nA = Int8.(A) # just for nicer display\n\nThe pattern of 0 and 1 elements is more obvious when reshaped:\n\nreshape(A, N, N)","category":"section"},{"location":"generated/examples/02-trace/#Adjoint","page":"Operator example: trace","title":"Adjoint","text":"Although this is largely a didactic example, there are optimization problems with trace constraints of the form ğ’œ X = b. To solve such problems, often one would also need the adjoint of the operator ğ’œ.\n\nMathematically, and adjoint is a generalization of the (Hermitian) transpose of a matrix. For a (bounded) linear mapping ğ’œ between inner product space ğ’³ with inner product  cdot cdot rangle_ğ’³ and inner product space ğ’´ with inner product  cdot cdot rangle_ğ’´ the adjoint of ğ’œ, denoted ğ’œ, is the unique bound linear mapping that satisfies  ğ’œ x y rangle_ğ’´ =  x ğ’œ y rangle_ğ’³ for all x  ğ’³ and y  ğ’´.\n\nHere, let ğ’³ denote the vector space of N  N matrices with the Frobenius inner product for matrices:  A B rangle_ğ’³ = mathrmtr(AB). Let ğ’´ simply be mathbbC^1 with the usual inner product  x y rangle_ğ’´ = x_1^* y_1.\n\nWith those definitions, one can verify that the adjoint of ğ’œ is the mapping ğ’œ c = c_1 mathbfI_N, for c  mathbbC^1, where mathbfI_N denotes the N  N identity matrix.\n\nHere is the LinearMapAO that includes the adjoint:\n\nback(y) = y[1] * I(N) # remember `y` is a 1-vector\nğ’œ = LinearMapAA(forw, back, (1, N*N); idim = (N,N), odim = (1,))\n\nHere is a verification that the adjoint is correct (very important!):\n\n@assert Matrix(ğ’œ)' == Matrix(ğ’œ')\nInt8.(Matrix(ğ’œ'))","category":"section"},{"location":"generated/examples/02-trace/#Reproducibility","page":"Operator example: trace","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/#LinearMapsAA.LinearMapsAA","page":"Methods","title":"LinearMapsAA.LinearMapsAA","text":"module LinearMapsAA\n\nProvides AbstractArray (actually AbstractMatrix) or \"Ann Arbor\" version of LinearMap objects\n\n\n\n\n\n","category":"module"},{"location":"methods/#LinearMapsAA.LinearMapAX","page":"Methods","title":"LinearMapsAA.LinearMapAX","text":"struct LinearMapAX{T,Do,Di,LM,P}\n\nUnion of LinearMapAM and LinearMapAO because most operations apply to both AM and AO types.\n\nT : eltype\nDo : output dimensionality\nDi : input dimensionality\nLM : LinearMap type\nP : NamedTuple type\n\n\n\n\n\n","category":"type"},{"location":"methods/#LinearMapsAA.LinearMapAM","page":"Methods","title":"LinearMapsAA.LinearMapAM","text":"struct LinearMapAM{T,Do,Di,LM,P} <: AbstractMatrix{T}\n\n\"matrix\" version that is quite akin to a matrix in its behavior\n\n\n\n\n\n","category":"type"},{"location":"methods/#LinearMapsAA.LinearMapAO","page":"Methods","title":"LinearMapsAA.LinearMapAO","text":"struct LinearMapAO{T,Do,Di,LM,P}\n\n\"Tensor\" version that can map from arrays to arrays. (It is not a subtype of AbstractArray.)\n\n\n\n\n\n","category":"type"},{"location":"methods/#LinearMapsAA.LinearMapAO-Union{Tuple{LinearMapAX{T, Do, Di, LM, P}}, Tuple{P}, Tuple{LM}, Tuple{Di}, Tuple{Do}, Tuple{T}} where {T, Do, Di, LM, P}","page":"Methods","title":"LinearMapsAA.LinearMapAO","text":"B = LinearMapAO(A::LinearMapAX)\n\nMake an AO from an AM, despite idim and odim being 1D, for expert users who want B*X to be an Array. Somewhat an opposite of undim.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.:*-Tuple{LinearAlgebra.UniformScaling, AbstractArray}","page":"Methods","title":"Base.:*","text":"*(I, X) = X\n*(J, X) = J.Î» * X\n\nExtends the effect of I::UniformScaling and scaled versions thereof to also apply to X::AbstractArray instead of just to Vector and Matrix types.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.:*-Tuple{LinearMapAO, AbstractVector{<:AbstractArray}}","page":"Methods","title":"Base.:*","text":"*(A::LinearMapAO, xv::AbstractVector{<:AbstractArray}) = [A * x for x in xv]\n\nFancy multiply when xv is a Vector of AbstractArrays of appropriate size.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.hcat-Tuple{LinearMapAO, Vararg{LinearMapAO}}","page":"Methods","title":"Base.hcat","text":"hcat(As::LinearMapAO... ; tryop::Bool=true)\n\nhcat with (by default) attempt to append nblock to idim if consistent blocks.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.hvcat-Tuple{NTuple{nr, Int64} where nr, LinearMapAO, Vararg{LinearMapAO}}","page":"Methods","title":"Base.hvcat","text":"hvcat(rows, As::LinearMapAO...)\n\nhvcat that discards special idim and odim information (too hard!) # todo?\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.kron-Tuple{LinearMapAM, AbstractMatrix}","page":"Methods","title":"Base.kron","text":"kron(A::LinearMapAX, M::AbstractMatrix)\nkron(M::AbstractMatrix, A::LinearMapAX)\nkron(A::LinearMapAX, B::LinearMapAX)\n\nKronecker products\n\nReturns a LinearMapAO with appropriate idim and odim if either argument is a LinearMapAO else returns a LinearMapAM\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.show-Tuple{IO, LinearMapAX}","page":"Methods","title":"Base.show","text":"show(io::IO, A::LinearMapAX)\nshow(io::IO, ::MIME\"text/plain\", A::LinearMapAX)\n\nPretty printing for display\n\n\n\n\n\n","category":"method"},{"location":"methods/#Base.vcat-Tuple{LinearMapAO, Vararg{LinearMapAO}}","page":"Methods","title":"Base.vcat","text":"vcat(As::LinearMapAO... ; tryop::Bool=true)\n\nvcat with (by default) attempt to append nblock to odim if consistent blocks.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearAlgebra.mul!-Tuple{AbstractVector{<:AbstractArray}, LinearMapAO, AbstractVector{<:AbstractArray}, Number, Number}","page":"Methods","title":"LinearAlgebra.mul!","text":" mul!(yv, AO::LinearMapAO, xv, Î±, Î²)\n\nFancy 5-arg multiply when yv and xv are each a Vector of AbstractArrays. Basically does mul!(yv[i], A, xv[i], Î±, Î²) for i in 1:length(xv).\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.LinearMapAA-Tuple{AbstractMatrix}","page":"Methods","title":"LinearMapsAA.LinearMapAA","text":"A = LinearMapAA(L::AbstractMatrix ; ...)\n\nConstructor given an AbstractMatrix.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.LinearMapAA-Tuple{Function, Function, Tuple{Int64, Int64}}","page":"Methods","title":"LinearMapsAA.LinearMapAA","text":"A = LinearMapAA(f::Function, fc::Function, D::Dims{2} [, prop::NamedTuple)]\n; T::Type = Float32, idim::Dims, odim::Dims)\n\nConstructor given forward f and adjoint function fc.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.LinearMapAA-Tuple{Function, Tuple{Int64, Int64}}","page":"Methods","title":"LinearMapsAA.LinearMapAA","text":"A = LinearMapAA(f::Function, D::Dims{2} [, prop::NamedTuple]; kwargs...)\n\nConstructor given just forward function f.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.LinearMapAA-Union{Tuple{P}, Tuple{LM}, Tuple{Do}, Tuple{Di}} where {Di, Do, LM<:LinearMaps.LinearMap, P<:NamedTuple}","page":"Methods","title":"LinearMapsAA.LinearMapAA","text":"A = LinearMapAA(L::LinearMap ; ...)\n\nConstructor for LinearMapAM  or LinearMapAO given a LinearMap.\n\nOptions\n\nprop::NamedTuple = NamedTuple(); cannot include the fields _lmap, _prop, _idim, _odim\nT::Type = eltype(L)\nidim::Dims = (size(L,2),)\nodim::Dims = (size(L,1),)\noperator::Bool by default: false if both idim & odim are 1D.\n\nOutput A is LinearMapAO if operator is true, else LinearMapAM.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.block_diag-Tuple{Vararg{LinearMapAO}}","page":"Methods","title":"LinearMapsAA.block_diag","text":"B = block_diag(As::LinearMapAX... ; tryop::Bool)\n\nMake block diagonal LinearMapAX object from blocks.\n\nReturn a LinearMapAM unless tryop and all blocks have same idim and odim.\n\nDefault for tryop is true if all blocks are type LinearMapAO.\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.lmaa_hcat-Tuple{Vararg{Union{LinearAlgebra.UniformScaling{T}, LinearMaps.LinearMap{T}, LinearMapAM{T}, LinearMapAO{T}} where T}}","page":"Methods","title":"LinearMapsAA.lmaa_hcat","text":"B = lmaa_hcat(A1, A2, ...) hcat of multiple objects\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.lmaa_hvcat-Tuple{NTuple{nr, Int64} where nr, Vararg{Union{LinearAlgebra.UniformScaling{T}, LinearMaps.LinearMap{T}, LinearMapAM{T}, LinearMapAO{T}} where T}}","page":"Methods","title":"LinearMapsAA.lmaa_hvcat","text":"B = lmaa_hvcat(rows, A1, A2, ...) hvcat of multiple objects\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.lmaa_vcat-Tuple{Vararg{Union{LinearAlgebra.UniformScaling{T}, LinearMaps.LinearMap{T}, LinearMapAM{T}, LinearMapAO{T}} where T}}","page":"Methods","title":"LinearMapsAA.lmaa_vcat","text":"B = lmaa_vcat(A1, A2, ...) vcat of multiple objects\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.lmao_mul!-Tuple{AbstractArray, LinearMaps.LinearMap, AbstractArray, Number, Number}","page":"Methods","title":"LinearMapsAA.lmao_mul!","text":" lmao_mul!(Y, A, X, Î±, Î² ; idim, odim)\n\nCore routine for 5-arg multiply. If A._idim = (2,3,4) and A._odim = (5,6) and if input X has size (2,3,4, 7,8) then output Y will have size (5,6, 7,8)\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.redim-Union{Tuple{LinearMapAX{T}}, Tuple{T}} where T","page":"Methods","title":"LinearMapsAA.redim","text":"redim(A::LinearMapAX ; idim::Dims=A._idim, odim::Dims=A._odim)\n\n\"Reinterpret\" the idim and odim of A\n\n\n\n\n\n","category":"method"},{"location":"methods/#LinearMapsAA.undim-Union{Tuple{LinearMapAX{T}}, Tuple{T}} where T","page":"Methods","title":"LinearMapsAA.undim","text":"undim(A::LinearMapAX)\n\n\"Reinterpret\" the idim and odim of A to be of AM type\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/01-overview/#01-overview","page":"LinearMapsAA overview","title":"LinearMapsAA overview","text":"This page illustrates the Julia package LinearMapsAA.\n\nThis page comes from a single Julia file: 01-overview.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 01-overview.ipynb, or open it in binder here: 01-overview.ipynb.","category":"section"},{"location":"generated/examples/01-overview/#Setup","page":"LinearMapsAA overview","title":"Setup","text":"Packages needed here.\n\nusing LinearMapsAA\nusing ImagePhantoms: shepp_logan, SheppLoganToft\nusing MIRTjim: jim, prompt\nusing InteractiveUtils: versioninfo\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/01-overview/#Overview","page":"LinearMapsAA overview","title":"Overview","text":"Many computational imaging methods use system models that are too large to store explicitly as dense matrices, but nevertheless are represented mathematically by a linear mapping A.\n\nOften that linear map is thought of as a matrix, but in imaging problems it often is more convenient to think of it as a more general linear operator.\n\nThe LinearMapsAA package can represent both \"matrix\" versions and \"operator\" versions of linear mappings. This page illustrates both versions in the context of single-image super-resolution imaging, where the operator A maps a M Ã— N image into a coarser sampled image of size MÃ·2 Ã— NÃ·2.\n\nHere the operator A is akin to down-sampling, except, rather than simple decimation, each coarse-resolution pixel is the average of a 2 Ã— 2 block of pixels in the fine-resolution image.","category":"section"},{"location":"generated/examples/01-overview/#System-operator-(linear-mapping)-for-down-sampling","page":"LinearMapsAA overview","title":"System operator (linear mapping) for down-sampling","text":"Here is the \"forward\" function needed to model 2Ã— down-sampling:\n\ndown1 = (x) -> (x[1:2:end,:] + x[2:2:end,:])/2 # 1D down-sampling by 2Ã—\ndown2 = (x) -> down1(down1(x)')'; # 2D down-sampling by factor of 2Ã—\nnothing #hide\n\nThe down2 function is a (bounded) linear operator and here is its adjoint:\n\ndown2_adj(y::AbstractMatrix{<:Number}) = kron(y, fill(0.25, (2,2)));\nnothing #hide\n\nMathematically, and adjoint is a generalization of the (Hermitian) transpose of a matrix. For a (bounded) linear mapping A between inner product space X with inner product <.,.>X and inner product space Y with inner product <.,.>Y, the adjoint of A, denoted A', is the unique bound linear mapping that satisfies <A x, y>Y = <x, A' y>X for all x âˆˆ X and y âˆˆ Y. One can verify that the down2_adj function satisfies that equality for the usual inner product on the space of M Ã— N images.","category":"section"},{"location":"generated/examples/01-overview/#LinearMap-as-an-operator-for-super-resolution","page":"LinearMapsAA overview","title":"LinearMap as an operator for super-resolution","text":"We now pick a specific image size and define the linear mapping using the two functions above:\n\nnx, ny = 200, 256\nA = LinearMapAA(down2, down2_adj, ((nxÃ·2)*(nyÃ·2), nx*ny);\n    idim = (nx,ny), odim = (nx,ny) .Ã· 2)\n\nThe idim argument specifies that the input image is of size nx Ã— ny and the odim argument specifies that the output image is of size nxÃ·2 Ã— nyÃ·2. This means that when we invoke y = A * x the input x must be a 2D array of size nx Ã— ny (not a 1D vector!) and the output y will have size nxÃ·2 Ã— nyÃ·2. This behavior is a generalization of what one might expect from a conventional matrix-vector expression, but is quite appropriate and convenient for imaging problems.\n\nHere is an illustration. We start with a 2D test image.\n\nimage = shepp_logan(ny, SheppLoganToft())[(ny-nx)Ã·2 .+ (1:nx),:]\njim(image, \"SheppLogan\")\n\nApply the operator A to this image to down-sample it:\n\ndown = A * image\njim(down, title=\"Down-sampled image\")\n\nApply the adjoint of A to that result to \"up-sample\" it:\n\nup = A' * down\njim(up, title=\"Adjoint: A' * y\")\n\nThat up-sampled image does not have the same range of values as the original image because A' is an adjoint, not an inverse!","category":"section"},{"location":"generated/examples/01-overview/#AbstractMatrix-version","page":"LinearMapsAA overview","title":"AbstractMatrix version","text":"Some users may prefer that the operator A behave more like a matrix. We can implement approach from the same ingredients by using vec and reshape judiciously. The code is less elegant, but similarly efficient because vec and reshape are non-allocating operations.\n\nB = LinearMapAA(\n        x -> vec(down2(reshape(x,nx,ny))),\n        y -> vec(down2_adj(reshape(y,Int(nx/2),Int(ny/2)))),\n        ((nxÃ·2)*(nyÃ·2), nx*ny),\n    )\n\nTo apply this version to our image we must first vectorize it because the expected input is a vector in this case. And then we have to reshape the vector output as a 2D array to look at it. (This is why the operator version with idim and odim is preferable.)\n\ny = B * vec(image) # This would fail here without the `vec`!\njim(reshape(y, nxÃ·2, nyÃ·2)) # Annoying reshape needed here!\n\nEven though we write y = A * x above, one must remember that internally A is not stored as a dense matrix. It is simply a special variable type that stores the forward function down2 and the adjoint function down2_adj, along with a few other values like nx,ny, and applies those functions when needed. Nevertheless, we can examine elements of A and B just like one would with any matrix, at least for small enough examples to fit in memory.\n\nExamine A and A'\n\nnx, ny = 8,6\nidim = (nx,ny)\nodim = (nx,ny) .Ã· 2\nA = LinearMapAA(down2, down2_adj, ((nxÃ·2)*(nyÃ·2), nx*ny); idim, odim)\n\nHere is A shown as a Matrix:\n\njim(Matrix(A)', \"A\")\n\nHere is A' shown as a Matrix:\n\njim(Matrix(A')', \"A'\")\n\nWhen defining the adjoint function of a linear mapping, it is very important to verify that it is correct (truly the adjoint).\n\nFor a small problem we simply use the following test:\n\n@assert Matrix(A)' == Matrix(A')\n\nFor some applications we must check approximate equality like this:\n\n@assert Matrix(A)' â‰ˆ Matrix(A')\n\nHere is a statistical test that is suitable for large operators. Often one would repeat this test several times:\n\nT = eltype(A)\nx = randn(T, idim)\ny = randn(T, odim)\n\n@assert sum((A*x) .* y) â‰ˆ sum(x .* (A'*y)) # <Ax,y> = <x,A'y>","category":"section"},{"location":"generated/examples/01-overview/#Reproducibility","page":"LinearMapsAA overview","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/03-fft/#03-fft","page":"Operator example: FFT","title":"Operator example: FFT","text":"This page illustrates the \"linear operator\" feature of the Julia package LinearMapsAA for the case of a multi-dimensional FFT operation.\n\nThis page comes from a single Julia file: 03-fft.jl.\n\nYou can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 03-fft.ipynb, or open it in binder here: 03-fft.ipynb.","category":"section"},{"location":"generated/examples/03-fft/#Setup","page":"Operator example: FFT","title":"Setup","text":"Packages needed here.\n\nusing LinearMapsAA\nusing FFTW: fft, bfft, fft!, bfft!\nusing MIRTjim: jim, prompt\nusing LazyGrids: btime\nusing BenchmarkTools: @benchmark\nusing InteractiveUtils: versioninfo\n\nThe following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.\n\nisinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"section"},{"location":"generated/examples/03-fft/#Overview","page":"Operator example: FFT","title":"Overview","text":"A 1D N-point discrete Fourier transform (DFT) is a linear operation that is naturally represented as a N Ã— N matrix.\n\nThe multi-dimensional DFT is a linear mapping that could be represented as a matrix, using the vec(â‹…) of its arguments, but it is more naturally represented as a linear operator A. For 2D images of size M  N, we can think the DFT as an operator A that maps a M  N matrix into a M  N matrix of DFT coefficients. In other words, A  mathbbC^M  N mapsto mathbbC^M  N.\n\nThe LinearMapsAA package can represent such an operator easily.\n\nWe first define appropriate forward and adjoint functions. We use fft! and bfft! to avoid unnecessary memory allocations.\n\nforw!(y, x) =  fft!(copyto!(y, x)) # forward mapping function\nback!(x, y) = bfft!(copyto!(x, y)) # adjoint mapping function\n\nBelow is the operator definition for (MN) = (816).\n\nBecause FFT returns complex numbers, we must use T=ComplexF32 here for LinearMaps to work properly.\n\nM,N = 16,8\nT = ComplexF32\nA = LinearMapAA(forw!, back!, (M*N, M*N); idim = (M,N), odim = (M,N), T)\n\nThe idim argument specifies that the input is a matrix of size M Ã— N and the odim argument specifies that the output is a matrix of size (M,N).\n\nHere is some verification that applying this operator to a matrix produces a correct result:\n\nX = ones(M,N)\n@assert A * X â‰ˆ M*N * ((1:M) .== 1)*((1:N) .== 1)' # Kronecker impulse\nX = rand(T, M, N)\n@assert A * X â‰ˆ fft(X)\n\nAlthough A here is not a matrix, we can convert it to a matrix (at least when M N is sufficiently small) to perhaps understand it better:\n\nAmat = Matrix(A)\nusing MIRTjim: jim\njim(\n jim(real(Amat)', \"Real(A)\"; prompt=false),\n jim(imag(Amat)', \"Imag(A)\"; prompt=false),\n)","category":"section"},{"location":"generated/examples/03-fft/#Adjoint","page":"Operator example: FFT","title":"Adjoint","text":"Here is a verification that the adjoint of the operator A is working correctly.\n\n@assert Matrix(A)' â‰ˆ Matrix(A')\n\nSome users might wonder if there is \"overhead\" in using the overloaded linear mapping A * x or mul!(y, A, x) compared to directly calling fft!(copyto!(y), x).\n\nHere are some timing tests that confirm that LinearMapsAA does not incur overhead.\n\nWe deliberately choose very small M,N, because any overhead will be most apparent when the fft computation itself is fast.\n\nx = rand(ComplexF32, M, N)\ny1 = similar(x)\ny2 = similar(x)\n\nmul!(y1, A, x)\nforw!(y2, x)\n@assert y1 == y2\nmul!(y1, A', x)\nback!(y2, x)\n@assert y1 == y2\n\ntime forward fft:\n\ntimer(t) = btime(t; unit=:Î¼s)\nt = @benchmark forw!($y2, $x)       # 19.1 us (31 alloc, 2K)\ntimer(t)\n\ncompare to LinearMapsAA version:\n\nt = @benchmark mul!($y1, $A, $x)    # 18.1 us (44 alloc, 4K)\ntimer(t)\n\ntime backward fft:\n\nt = @benchmark back!($y2, $x)       # 19.443 Î¼s (31 allocations: 2.12 KiB)\ntimer(t)\n\ncompare to LinearMapsAA version:\n\nt = @benchmark mul!($y1, $(A'), $x) # 17.855 Î¼s (44 allocations: 4.00 KiB)\ntimer(t)","category":"section"},{"location":"generated/examples/03-fft/#Reproducibility","page":"Operator example: FFT","title":"Reproducibility","text":"This page was generated with the following version of Julia:\n\nusing InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')\n\nAnd with the following package versions\n\nimport Pkg; Pkg.status()\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#LinearMapsAA.jl-Documentation","page":"Home","title":"LinearMapsAA.jl Documentation","text":"","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Currently the main documentation for (LinearMapsAA) is in the README file therein.\n\nSee also the documentation for the underlying (LinearMaps) package.\n\nSee the Example(s) tab for one non-trivial example.","category":"section"}]
}
